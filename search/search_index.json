{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Conda-pack for SLAC This documentation describes the conda-pack workflow used for assembling production compliant custom Python environments. We use a GitHub action to build a conda environment and execute tests within a Docker image aimed to capture the constraints of a production machine. At present, the action supports environments for LCLS RHEL6 machines. Researchers may package their code with a designated environment.yml file describing the Python environment relevant to their project or create a designated repository for an environment supporting many projects. Building an environment Steps: Describe the conda environment in the environment.yml file in the root of your project repository. Pin versions for only essential packages. Attempt to use only conda-forge maintained packages. Write a bash script capturing all intended behaviors of your environment. You may assume your generated Python environment will be active. See: tests Add publish Github action yaml in the .github/workflows folder of your project repository. Create release. Creating a release Two example actions are outlined in actions : 1. a generic testing build executed on all pushed commits to the main branch and 2. a publish workflow that executes the build on a tagged release then publishes a tarred environment to the release tag. Releases and tags must be used to preserve versioning and identify incompatibilities. Using the environment A published environment will be available as a file attached to a release. Following download, the environment may be untarred then unpacked: $ mkdir my_environment $ tar -xvf my_environment.tar.gz -C my_environment $ source my_environment/bin/activate $ my_environment/bin/conda-unpack The environment will not work if moved after running unpack. Make sure to perform the above in the same location you'd like the environment to live. The resulting environment may then be used by sourcing source path/to/my_environment/bin/activate going forward. Deploying to production In order to deploy your release to production, post in the lcls-python-environments Slack channel. We will work with the developer on executing additional tests on dev beore deploying to prod. Functionality cannot be guaranteed beyond that described in testing. All deployments will be tracked through jobs submitted on CATER #152805. Notes This workflow will attempt to support all conda-forge maintained packages. Other packages (pip etc.) may be accepted given sufficient warning to (post in lcls-python-environments channel for consult); however, miscellaneous support cannot be guaranteed.","title":"Overview"},{"location":"#conda-pack-for-slac","text":"This documentation describes the conda-pack workflow used for assembling production compliant custom Python environments. We use a GitHub action to build a conda environment and execute tests within a Docker image aimed to capture the constraints of a production machine. At present, the action supports environments for LCLS RHEL6 machines. Researchers may package their code with a designated environment.yml file describing the Python environment relevant to their project or create a designated repository for an environment supporting many projects.","title":"Conda-pack for SLAC"},{"location":"#building-an-environment","text":"Steps: Describe the conda environment in the environment.yml file in the root of your project repository. Pin versions for only essential packages. Attempt to use only conda-forge maintained packages. Write a bash script capturing all intended behaviors of your environment. You may assume your generated Python environment will be active. See: tests Add publish Github action yaml in the .github/workflows folder of your project repository. Create release.","title":"Building an environment"},{"location":"#creating-a-release","text":"Two example actions are outlined in actions : 1. a generic testing build executed on all pushed commits to the main branch and 2. a publish workflow that executes the build on a tagged release then publishes a tarred environment to the release tag. Releases and tags must be used to preserve versioning and identify incompatibilities.","title":"Creating a release"},{"location":"#using-the-environment","text":"A published environment will be available as a file attached to a release. Following download, the environment may be untarred then unpacked: $ mkdir my_environment $ tar -xvf my_environment.tar.gz -C my_environment $ source my_environment/bin/activate $ my_environment/bin/conda-unpack The environment will not work if moved after running unpack. Make sure to perform the above in the same location you'd like the environment to live. The resulting environment may then be used by sourcing source path/to/my_environment/bin/activate going forward.","title":"Using the environment"},{"location":"#deploying-to-production","text":"In order to deploy your release to production, post in the lcls-python-environments Slack channel. We will work with the developer on executing additional tests on dev beore deploying to prod. Functionality cannot be guaranteed beyond that described in testing. All deployments will be tracked through jobs submitted on CATER #152805.","title":"Deploying to production"},{"location":"#notes","text":"This workflow will attempt to support all conda-forge maintained packages. Other packages (pip etc.) may be accepted given sufficient warning to (post in lcls-python-environments channel for consult); however, miscellaneous support cannot be guaranteed.","title":"Notes"},{"location":"action/","text":"Conda pack for custom LCLS Python environments A GitHub action has been defined for the creation and testing of a Python environment using a RHEL6 Docker image aimed at replicating the installation environment of LCLS prod machines. In order to use this in a project, the repository must be packaged with a root level environment.yml file constructed using the conda template . The action creates an environment from this file within the context of the RHEL6 docker image specified by lcls-rhel6-conda-docker and will store the artifact. The use of this action in a worklow requires defining the environment variable ENVIRONMENT_NAME , which should match the name specified in the environment.yml . Optionally (but encouraged), a test bash script may be packaged with the environment repository and indicated to the docker image using TEST_FILE environment variable. Build The below worflow executes a puild and test of the environment on pushes to the main branch. name: Create conda environment for my-environment on: push: branches: - main jobs: build: env: ENVIRONMENT_NAME: my-environment TEST_FILE: my-test-file.sh runs-on: ubuntu-latest name: Build environment steps: - name: Build environment uses: jacquelinegarrahan/lcls-rhel6-conda-pack@v1.2 Publish Extending the above workflow, we can access the tarred environment in the working directory of the action with the naming scheme ${ENVIRONMENT_NAME}.tar.gz For example, the following action will upload the packed environment on pushed tags. Creating releases on the repository will publish the tarred environment to the release artifacts, then available for download. name: Publish release on: push: tags: - '*' jobs: build: env: ENVIRONMENT_NAME: my-environment TEST_FILE: my-test-file.sh runs-on: ubuntu-latest name: Build environment steps: - name: Build environment uses: jacquelinegarrahan/lcls-rhel6-conda-pack@v1.2 - name: Upload artifact to release uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: ${{ env.ENVIRONMENT_NAME }}.tar.gz tag: ${{ github.ref }} overwrite: true file_glob: true","title":"Github Actions"},{"location":"action/#conda-pack-for-custom-lcls-python-environments","text":"A GitHub action has been defined for the creation and testing of a Python environment using a RHEL6 Docker image aimed at replicating the installation environment of LCLS prod machines. In order to use this in a project, the repository must be packaged with a root level environment.yml file constructed using the conda template . The action creates an environment from this file within the context of the RHEL6 docker image specified by lcls-rhel6-conda-docker and will store the artifact. The use of this action in a worklow requires defining the environment variable ENVIRONMENT_NAME , which should match the name specified in the environment.yml . Optionally (but encouraged), a test bash script may be packaged with the environment repository and indicated to the docker image using TEST_FILE environment variable.","title":"Conda pack for custom LCLS Python environments"},{"location":"action/#build","text":"The below worflow executes a puild and test of the environment on pushes to the main branch. name: Create conda environment for my-environment on: push: branches: - main jobs: build: env: ENVIRONMENT_NAME: my-environment TEST_FILE: my-test-file.sh runs-on: ubuntu-latest name: Build environment steps: - name: Build environment uses: jacquelinegarrahan/lcls-rhel6-conda-pack@v1.2","title":"Build"},{"location":"action/#publish","text":"Extending the above workflow, we can access the tarred environment in the working directory of the action with the naming scheme ${ENVIRONMENT_NAME}.tar.gz For example, the following action will upload the packed environment on pushed tags. Creating releases on the repository will publish the tarred environment to the release artifacts, then available for download. name: Publish release on: push: tags: - '*' jobs: build: env: ENVIRONMENT_NAME: my-environment TEST_FILE: my-test-file.sh runs-on: ubuntu-latest name: Build environment steps: - name: Build environment uses: jacquelinegarrahan/lcls-rhel6-conda-pack@v1.2 - name: Upload artifact to release uses: svenstaro/upload-release-action@v2 with: repo_token: ${{ secrets.GITHUB_TOKEN }} file: ${{ env.ENVIRONMENT_NAME }}.tar.gz tag: ${{ github.ref }} overwrite: true file_glob: true","title":"Publish"},{"location":"docker/","text":"lcls-rhel6-conda-docker The Docker image used by the conda-pack action aims replicate an LCLS production RHEL6 machines for environment build and test. While resolved conda environments are largely transferable, there are some instances of virtual packages that may break a packed environment. Virtual packages include __cuda , __osx , __glibc , __linux , __unix , __win . Of particular importance to our conda environment builds is the glibc version. The RHEL6 glibc=2.12 , may be incompatible with some compiled code. For this reason, we aim to pack our environments in as-similar-a-machine as possible to catch these issues before movind to prod. Additional requirements and tests may be added as needed, with the aim of a robust testing tool before deployment. The image requires mounting of an environment file to /tmp/environment.yml , mounting of the repository to /tmp/project , mounting of a testing script to /tmp/run-test.sh , and setting of the environment variable ENVIRONMENT_NAME . Environment files may be tested using this image locally with a docker installation: $ docker run -v $(pwd)/environment.yml:/tmp/environment.yml \\ -v $(pwd):/tmp/project \\ -v /complete/path/to/test/file.sh:/tmp/run-test.sh \\ -e ENVIRONMENT_NAME=my_environment \\ -t jgarrahan/lcls-rhel6-conda-docker:v1.0 /tmp/environment.yml These are all handled by the GitHub action slaclab/lcls-rhel6-conda-pack . Releases to this repository trigger a workflow that builds the docker image using the repository Dockerfile. The resulting image is published to dockerhub using the release version as a tag. Tests The Docker image expects tests defined and run using a bash script mounted to /tmp/run-test.sh . An effort should be made by code developers to implement a comprehensive set of tests for their packages with the understanding that the efficacy of this pack-and-test process is a function of their effort in doing so. The Python environment described by their yaml will be active during test script execution.","title":"Docker"},{"location":"docker/#lcls-rhel6-conda-docker","text":"The Docker image used by the conda-pack action aims replicate an LCLS production RHEL6 machines for environment build and test. While resolved conda environments are largely transferable, there are some instances of virtual packages that may break a packed environment. Virtual packages include __cuda , __osx , __glibc , __linux , __unix , __win . Of particular importance to our conda environment builds is the glibc version. The RHEL6 glibc=2.12 , may be incompatible with some compiled code. For this reason, we aim to pack our environments in as-similar-a-machine as possible to catch these issues before movind to prod. Additional requirements and tests may be added as needed, with the aim of a robust testing tool before deployment. The image requires mounting of an environment file to /tmp/environment.yml , mounting of the repository to /tmp/project , mounting of a testing script to /tmp/run-test.sh , and setting of the environment variable ENVIRONMENT_NAME . Environment files may be tested using this image locally with a docker installation: $ docker run -v $(pwd)/environment.yml:/tmp/environment.yml \\ -v $(pwd):/tmp/project \\ -v /complete/path/to/test/file.sh:/tmp/run-test.sh \\ -e ENVIRONMENT_NAME=my_environment \\ -t jgarrahan/lcls-rhel6-conda-docker:v1.0 /tmp/environment.yml These are all handled by the GitHub action slaclab/lcls-rhel6-conda-pack . Releases to this repository trigger a workflow that builds the docker image using the repository Dockerfile. The resulting image is published to dockerhub using the release version as a tag.","title":"lcls-rhel6-conda-docker"},{"location":"docker/#tests","text":"The Docker image expects tests defined and run using a bash script mounted to /tmp/run-test.sh . An effort should be made by code developers to implement a comprehensive set of tests for their packages with the understanding that the efficacy of this pack-and-test process is a function of their effort in doing so. The Python environment described by their yaml will be active during test script execution.","title":"Tests"},{"location":"examples/","text":"Example Projects Badger Environment LCLS Python3.8 Environment LCLS Injector Tuning Environment","title":"Examples"},{"location":"examples/#example-projects","text":"Badger Environment LCLS Python3.8 Environment LCLS Injector Tuning Environment","title":"Example Projects"},{"location":"issues/","text":"Issues Unfortunately, despite all best efforts, cases will inevitable arise with external packages. This may be a function of undocumented dependencies, broken packages, or dependence on newer libraries unavailable on RHEL6. The Slack lcls-python-environments channel will be used for discussing ongoing issues and we'll document all findings and workarounds here. Known issues Use of both Tensorflow and Scikit-Learn require mkl to be listed as a dependency. This issue may be identified with, ImportError: dlopen: cannot load any more object with static TLS during build. PyQt6 has not yet been built on conda-forge. Until then, projects are constrained to PyQt5 and below","title":"Issues"},{"location":"issues/#issues","text":"Unfortunately, despite all best efforts, cases will inevitable arise with external packages. This may be a function of undocumented dependencies, broken packages, or dependence on newer libraries unavailable on RHEL6. The Slack lcls-python-environments channel will be used for discussing ongoing issues and we'll document all findings and workarounds here.","title":"Issues"},{"location":"issues/#known-issues","text":"Use of both Tensorflow and Scikit-Learn require mkl to be listed as a dependency. This issue may be identified with, ImportError: dlopen: cannot load any more object with static TLS during build. PyQt6 has not yet been built on conda-forge. Until then, projects are constrained to PyQt5 and below","title":"Known issues"},{"location":"tests/","text":"Tests The Docker image used by the pack flow will execute tests described in a bash script. name: Create conda environment for my-environment on: push: branches: - main jobs: build: env: ENVIRONMENT_NAME: my-environment TEST_FILE: my-test-file.sh Code developers should implement comprehensive testing for their packages. Production behavior can only be supported to the extent that the code behavior is described by in tests. The bash script is intended to give flexibility to the project and allow for various testing frameworks and multiple test projects. An effort will be made downstream to accomodate the installation of testing packages outside of the project environment.yml , but for now testing packages like pytest should be included in the environment description. Example An example test file running a pytest suite for a repository is given below: #!/bin/bash set -e git clone https://github.com/slaclab/lume-epics.git cd lume-epics pytest The flag: #!/bin/bash set -e should be included at the top of the testing script to force exit on failed subcommands. If testing multiple repositories, the script should take care to remove previously tested repositories as to not deplete space in the container. #!/bin/bash set -e # test lume-epics git clone https://github.com/slaclab/lume-epics.git cd lume-epics pytest # remove already tested cd .. rm -rf lume-epics # test lume-model git clone https://github.com/slaclab/lume-model.git cd lume-model pytest Testing your code with pytest Testing with pytest can make existence significantly easier by identifying failures as you develop and reducing bug discovery time. Tests should at least cover the major data structures and functionality of your project. For many SLAC based projects, this may require a restructuring of essential functions into utility scripts rather than notebooks and packaging projects using Python packaging standards.","title":"Tests"},{"location":"tests/#tests","text":"The Docker image used by the pack flow will execute tests described in a bash script. name: Create conda environment for my-environment on: push: branches: - main jobs: build: env: ENVIRONMENT_NAME: my-environment TEST_FILE: my-test-file.sh Code developers should implement comprehensive testing for their packages. Production behavior can only be supported to the extent that the code behavior is described by in tests. The bash script is intended to give flexibility to the project and allow for various testing frameworks and multiple test projects. An effort will be made downstream to accomodate the installation of testing packages outside of the project environment.yml , but for now testing packages like pytest should be included in the environment description.","title":"Tests"},{"location":"tests/#example","text":"An example test file running a pytest suite for a repository is given below: #!/bin/bash set -e git clone https://github.com/slaclab/lume-epics.git cd lume-epics pytest The flag: #!/bin/bash set -e should be included at the top of the testing script to force exit on failed subcommands. If testing multiple repositories, the script should take care to remove previously tested repositories as to not deplete space in the container. #!/bin/bash set -e # test lume-epics git clone https://github.com/slaclab/lume-epics.git cd lume-epics pytest # remove already tested cd .. rm -rf lume-epics # test lume-model git clone https://github.com/slaclab/lume-model.git cd lume-model pytest","title":"Example"},{"location":"tests/#testing-your-code-with-pytest","text":"Testing with pytest can make existence significantly easier by identifying failures as you develop and reducing bug discovery time. Tests should at least cover the major data structures and functionality of your project. For many SLAC based projects, this may require a restructuring of essential functions into utility scripts rather than notebooks and packaging projects using Python packaging standards.","title":"Testing your code with pytest"}]}